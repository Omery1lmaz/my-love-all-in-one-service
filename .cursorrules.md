# Cursor Rules - YaÅŸam KoÃ§larÄ± AI Sistemi

## ğŸ¯ Proje Genel KurallarÄ±

### Kod YazÄ±m StandartlarÄ±
- **Dil:** TÃ¼rkÃ§e yorumlar ve deÄŸiÅŸken isimleri kullan
- **Format:** Prettier ve ESLint kurallarÄ±na uy
- **Indent:** 2 space kullan
- **Encoding:** UTF-8
- **Line Endings:** LF (Unix)
- **Max Line Length:** 80 karakter
- **Semicolon:** Zorunlu
- **Quotes:** Single quote kullan

### TypeScript/JavaScript KurallarÄ±
```typescript
// Interface tanÄ±mlarÄ±
interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
}

// Type tanÄ±mlarÄ±
type ApiResponse<T> = {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
};

// Enum kullanÄ±mÄ±
enum CoachType {
  GENERAL = 'general',
  RELATIONSHIP = 'relationship_coach',
  CAREER = 'career_coach',
  HEALTH = 'health_coach',
  PERSONAL_DEVELOPMENT = 'personal_development_coach',
  FINANCIAL = 'financial_coach'
}

// Async/await kullanÄ±mÄ±
const getUserData = async (userId: string): Promise<User> => {
  try {
    const user = await User.findById(userId);
    if (!user) {
      throw new Error('KullanÄ±cÄ± bulunamadÄ±');
    }
    return user;
  } catch (error) {
    throw new Error(`KullanÄ±cÄ± verisi alÄ±namadÄ±: ${error.message}`);
  }
};
```

### Dosya Organizasyonu
```
src/
â”œâ”€â”€ controllers/          # Controller dosyalarÄ±
â”œâ”€â”€ routes/              # Route dosyalarÄ±
â”œâ”€â”€ models/              # Mongoose model dosyalarÄ±
â”œâ”€â”€ middlewares/         # Middleware dosyalarÄ±
â”œâ”€â”€ validators/          # Express-validator dosyalarÄ±
â”œâ”€â”€ utils/               # Utility fonksiyonlarÄ±
â”œâ”€â”€ types/               # TypeScript type tanÄ±mlarÄ±
â”œâ”€â”€ services/            # Business logic
â”œâ”€â”€ config/              # KonfigÃ¼rasyon dosyalarÄ±
â””â”€â”€ __tests__/           # Test dosyalarÄ±
```

## ğŸ” Authentication & Authorization KurallarÄ±

### JWT Token YapÄ±sÄ±
```typescript
// Token payload interface
interface TokenPayload {
  userId: string;
  email: string;
  role: 'user' | 'admin';
  iat: number;
  exp: number;
}

// Token oluÅŸturma
const createToken = (user: User): string => {
  const payload: TokenPayload = {
    userId: user.id,
    email: user.email,
    role: user.role,
    iat: Date.now(),
    exp: Date.now() + (24 * 60 * 60 * 1000) // 24 saat
  };
  
  return jwt.sign(payload, process.env.JWT_SECRET!, {
    algorithm: 'HS256',
    expiresIn: '24h'
  });
};

// Token doÄŸrulama
const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET!) as TokenPayload;
  } catch (error) {
    throw new Error('GeÃ§ersiz token');
  }
};
```

### Authentication Middleware
```typescript
// requireAuth middleware
export const requireAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        success: false,
        message: 'Authorization header eksik'
      });
      return;
    }

    const token = authHeader.split(' ')[1];
    const payload = verifyToken(token);
    
    // KullanÄ±cÄ±yÄ± veritabanÄ±ndan kontrol et
    const user = await User.findById(payload.userId);
    if (!user || !user.isActive) {
      res.status(401).json({
        success: false,
        message: 'KullanÄ±cÄ± bulunamadÄ± veya aktif deÄŸil'
      });
      return;
    }

    req.currentUser = user;
    next();
  } catch (error) {
    res.status(401).json({
      success: false,
      message: 'GeÃ§ersiz token'
    });
  }
};

// Role-based authorization
export const requireRole = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.currentUser) {
      res.status(401).json({
        success: false,
        message: 'KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±'
      });
      return;
    }

    if (!roles.includes(req.currentUser.role)) {
      res.status(403).json({
        success: false,
        message: 'Bu iÅŸlem iÃ§in yetkiniz yok'
      });
      return;
    }

    next();
  };
};
```

### Session Management
```typescript
// Session kontrolÃ¼
export const checkSessionOwnership = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { sessionId } = req.params;
    const userId = req.currentUser?.id;

    const session = await AIChatSession.findOne({
      sessionId,
      userId,
      isActive: true
    });

    if (!session) {
      res.status(404).json({
        success: false,
        message: 'Sohbet bulunamadÄ± veya eriÅŸim izniniz yok'
      });
      return;
    }

    req.session = session;
    next();
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Session kontrolÃ¼ sÄ±rasÄ±nda hata oluÅŸtu'
    });
  }
};
```

## ğŸ“¡ API Response KurallarÄ±

### Standard Response Format
```typescript
// BaÅŸarÄ±lÄ± yanÄ±t
interface SuccessResponse<T> {
  success: true;
  data: T;
  message?: string;
  timestamp: string;
}

// Hata yanÄ±tÄ±
interface ErrorResponse {
  success: false;
  message: string;
  error?: string;
  status?: number;
  timestamp: string;
}

// Response helper fonksiyonlarÄ±
export const sendSuccess = <T>(
  res: Response,
  data: T,
  message?: string,
  status: number = 200
): void => {
  const response: SuccessResponse<T> = {
    success: true,
    data,
    message,
    timestamp: new Date().toISOString()
  };
  
  res.status(status).json(response);
};

export const sendError = (
  res: Response,
  message: string,
  error?: string,
  status: number = 500
): void => {
  const response: ErrorResponse = {
    success: false,
    message,
    error,
    status,
    timestamp: new Date().toISOString()
  };
  
  res.status(status).json(response);
};
```

### HTTP Status KodlarÄ±
```typescript
// BaÅŸarÄ±lÄ± yanÄ±tlar
200: OK                    // GET, PUT, PATCH
201: Created              // POST
204: No Content           // DELETE

// Client hatalarÄ±
400: Bad Request          // GeÃ§ersiz input
401: Unauthorized         // Authentication gerekli
403: Forbidden            // Authorization yetersiz
404: Not Found            // Kaynak bulunamadÄ±
409: Conflict             // Ã‡akÄ±ÅŸma
422: Unprocessable Entity // Validation hatasÄ±
429: Too Many Requests    // Rate limit

// Server hatalarÄ±
500: Internal Server Error
502: Bad Gateway
503: Service Unavailable
```

## ğŸ—„ï¸ Database KurallarÄ±

### Mongoose Schema KurallarÄ±
```typescript
// User Schema Ã¶rneÄŸi
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'Email adresi zorunludur'],
    unique: true,
    lowercase: true,
    trim: true,
    validate: {
      validator: (email: string) => {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
      },
      message: 'GeÃ§ersiz email formatÄ±'
    }
  },
  name: {
    type: String,
    required: [true, 'Ä°sim zorunludur'],
    trim: true,
    minlength: [2, 'Ä°sim en az 2 karakter olmalÄ±dÄ±r'],
    maxlength: [50, 'Ä°sim en fazla 50 karakter olabilir']
  },
  password: {
    type: String,
    required: [true, 'Åifre zorunludur'],
    minlength: [6, 'Åifre en az 6 karakter olmalÄ±dÄ±r']
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastLoginAt: {
    type: Date
  }
}, {
  timestamps: true,
  toJSON: {
    transform: (doc, ret) => {
      delete ret.password;
      return ret;
    }
  }
});

// Index'ler
userSchema.index({ email: 1 });
userSchema.index({ isActive: 1 });
userSchema.index({ createdAt: -1 });

// Virtual fields
userSchema.virtual('fullName').get(function() {
  return `${this.name}`;
});

// Instance methods
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

// Static methods
userSchema.statics.findByEmail = function(email: string) {
  return this.findOne({ email, isActive: true });
};

// Pre-save middleware
userSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 12);
  }
  next();
});
```

### Query Optimizasyonu
```typescript
// Efficient query Ã¶rnekleri
// âŒ KÃ¶tÃ¼
const users = await User.find().select('name email');

// âœ… Ä°yi
const users = await User.find({ isActive: true })
  .select('name email createdAt')
  .sort({ createdAt: -1 })
  .limit(10)
  .lean();

// âŒ KÃ¶tÃ¼ - N+1 problem
const sessions = await AIChatSession.find({ userId });
for (const session of sessions) {
  const user = await User.findById(session.userId);
}

// âœ… Ä°yi - Populate kullan
const sessions = await AIChatSession.find({ userId })
  .populate('userId', 'name email')
  .lean();
```

## ğŸ”§ Error Handling KurallarÄ±

### Custom Error Classes
```typescript
// Base error class
class AppError extends Error {
  public statusCode: number;
  public isOperational: boolean;

  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

// Specific error classes
class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400);
  }
}

class AuthenticationError extends AppError {
  constructor(message: string = 'Kimlik doÄŸrulama baÅŸarÄ±sÄ±z') {
    super(message, 401);
  }
}

class AuthorizationError extends AppError {
  constructor(message: string = 'Bu iÅŸlem iÃ§in yetkiniz yok') {
    super(message, 403);
  }
}

class NotFoundError extends AppError {
  constructor(resource: string = 'Kaynak') {
    super(`${resource} bulunamadÄ±`, 404);
  }
}
```

### Global Error Handler
```typescript
// Error handling middleware
export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  let statusCode = 500;
  let message = 'Sunucu hatasÄ±';

  // AppError instance kontrolÃ¼
  if (error instanceof AppError) {
    statusCode = error.statusCode;
    message = error.message;
  }

  // Mongoose validation error
  if (error.name === 'ValidationError') {
    statusCode = 400;
    message = 'Validation hatasÄ±';
  }

  // Mongoose duplicate key error
  if (error.code === 11000) {
    statusCode = 409;
    message = 'Bu kayÄ±t zaten mevcut';
  }

  // JWT errors
  if (error.name === 'JsonWebTokenError') {
    statusCode = 401;
    message = 'GeÃ§ersiz token';
  }

  if (error.name === 'TokenExpiredError') {
    statusCode = 401;
    message = 'Token sÃ¼resi dolmuÅŸ';
  }

  // Log error
  console.error('Error:', {
    message: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    userId: req.currentUser?.id
  });

  // Send response
  res.status(statusCode).json({
    success: false,
    message,
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
  });
};
```

## ğŸ“ Validation KurallarÄ±

### Express-Validator KurallarÄ±
```typescript
// Validation helper
export const validateRequest = (req: Request, res: Response, next: NextFunction): void => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map(error => error.msg);
    
    res.status(400).json({
      success: false,
      message: 'Validation hatasÄ±',
      errors: errorMessages
    });
    return;
  }
  
  next();
};

// Validation rules
export const createChatSessionValidator = [
  body('title')
    .optional()
    .isString()
    .withMessage('BaÅŸlÄ±k string olmalÄ±dÄ±r')
    .isLength({ min: 1, max: 100 })
    .withMessage('BaÅŸlÄ±k 1-100 karakter arasÄ±nda olmalÄ±dÄ±r')
    .trim(),
  
  body('coachType')
    .optional()
    .isIn(['general', 'relationship_coach', 'career_coach', 'health_coach', 'personal_development_coach', 'financial_coach'])
    .withMessage('GeÃ§ersiz koÃ§ tÃ¼rÃ¼'),
  
  body('coachId')
    .optional()
    .isString()
    .withMessage('KoÃ§ ID\'si string olmalÄ±dÄ±r')
    .isLength({ min: 1 })
    .withMessage('KoÃ§ ID\'si boÅŸ olamaz'),
  
  validateRequest
];

export const sendMessageValidator = [
  body('message')
    .isString()
    .withMessage('Mesaj string olmalÄ±dÄ±r')
    .isLength({ min: 1, max: 1000 })
    .withMessage('Mesaj 1-1000 karakter arasÄ±nda olmalÄ±dÄ±r')
    .trim(),
  
  validateRequest
];

export const updateProfileValidator = [
  body('name')
    .optional()
    .isString()
    .withMessage('Ä°sim string olmalÄ±dÄ±r')
    .isLength({ min: 2, max: 50 })
    .withMessage('Ä°sim 2-50 karakter arasÄ±nda olmalÄ±dÄ±r')
    .trim(),
  
  body('email')
    .optional()
    .isEmail()
    .withMessage('GeÃ§erli bir email adresi giriniz')
    .normalizeEmail(),
  
  validateRequest
];
```

## ğŸ”„ Rate Limiting KurallarÄ±

### Rate Limiting Middleware
```typescript
import rateLimit from 'express-rate-limit';

// General rate limiter
export const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 dakika
  max: 100, // IP baÅŸÄ±na maksimum 100 istek
  message: {
    success: false,
    message: 'Ã‡ok fazla istek gÃ¶nderildi. LÃ¼tfen 15 dakika sonra tekrar deneyin.'
  },
  standardHeaders: true,
  legacyHeaders: false
});

// AI chat rate limiter
export const aiChatLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 dakika
  max: 10, // KullanÄ±cÄ± baÅŸÄ±na maksimum 10 AI isteÄŸi
  message: {
    success: false,
    message: 'AI istek limiti aÅŸÄ±ldÄ±. LÃ¼tfen 1 dakika sonra tekrar deneyin.'
  },
  keyGenerator: (req) => req.currentUser?.id || req.ip
});

// Login rate limiter
export const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 dakika
  max: 5, // IP baÅŸÄ±na maksimum 5 login denemesi
  message: {
    success: false,
    message: 'Ã‡ok fazla login denemesi. LÃ¼tfen 15 dakika sonra tekrar deneyin.'
  },
  skipSuccessfulRequests: true
});
```

## ğŸ§ª Test KurallarÄ±

### Test YazÄ±m StandartlarÄ±
```typescript
// Test dosya yapÄ±sÄ±
describe('AI Chat Controller', () => {
  let mockUser: User;
  let mockSession: AIChatSession;

  beforeEach(async () => {
    // Test setup
    mockUser = await createTestUser();
    mockSession = await createTestSession(mockUser.id);
  });

  afterEach(async () => {
    // Cleanup
    await cleanupTestData();
  });

  describe('POST /sessions/:sessionId/messages', () => {
    it('should send message successfully', async () => {
      // Arrange
      const message = 'Merhaba koÃ§';
      const request = {
        body: { message },
        params: { sessionId: mockSession.sessionId },
        currentUser: mockUser
      };

      // Mock AI response
      jest.spyOn(aiClient, 'chatWithLifeCoach').mockResolvedValue({
        response: 'Merhaba! Size nasÄ±l yardÄ±mcÄ± olabilirim?',
        status: 'success'
      });

      // Act
      const response = await sendMessage(request as any, mockResponse);

      // Assert
      expect(response.status).toBe(200);
      expect(response.json).toHaveBeenCalledWith({
        success: true,
        data: expect.objectContaining({
          message: expect.objectContaining({
            content: 'Merhaba! Size nasÄ±l yardÄ±mcÄ± olabilirim?'
          })
        })
      });
    });

    it('should return 404 for non-existent session', async () => {
      // Arrange
      const request = {
        body: { message: 'Test' },
        params: { sessionId: 'non-existent' },
        currentUser: mockUser
      };

      // Act
      const response = await sendMessage(request as any, mockResponse);

      // Assert
      expect(response.status).toBe(404);
      expect(response.json).toHaveBeenCalledWith({
        success: false,
        message: 'Chat session bulunamadÄ±'
      });
    });
  });
});
```

## ğŸ“Š Logging KurallarÄ±

### Structured Logging
```typescript
import winston from 'winston';

// Logger configuration
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

// Development logging
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

// Logging middleware
export const requestLogger = (req: Request, res: Response, next: NextFunction): void => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    logger.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: `${duration}ms`,
      userId: req.currentUser?.id,
      userAgent: req.get('User-Agent'),
      ip: req.ip
    });
  });
  
  next();
};

// Error logging
export const errorLogger = (error: Error, req: Request): void => {
  logger.error('Application Error', {
    message: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    userId: req.currentUser?.id,
    body: req.body,
    params: req.params,
    query: req.query
  });
};
```

## ğŸ”’ Security KurallarÄ±

### Security Headers
```typescript
import helmet from 'helmet';

// Security middleware
export const securityMiddleware = [
  helmet(),
  helmet.contentSecurityPolicy({
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  }),
  helmet.hidePoweredBy(),
  helmet.noSniff(),
  helmet.xssFilter()
];
```

### Input Sanitization
```typescript
import DOMPurify from 'isomorphic-dompurify';

// Input sanitization
export const sanitizeInput = (input: string): string => {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [],
    ALLOWED_ATTR: []
  });
};

// Sanitization middleware
export const sanitizeBody = (req: Request, res: Response, next: NextFunction): void => {
  if (req.body) {
    Object.keys(req.body).forEach(key => {
      if (typeof req.body[key] === 'string') {
        req.body[key] = sanitizeInput(req.body[key]);
      }
    });
  }
  next();
};
```

// Bu kurallar projenin kalitesini, gÃ¼venliÄŸini ve sÃ¼rdÃ¼rÃ¼lebilirliÄŸini artÄ±rmak iÃ§in tasarlanmÄ±ÅŸtÄ±r. GeliÅŸtirme sÃ¼recinde bu kurallara uyulmasÄ± zorunludur.
