# Cursor Rules - Yaşam Koçları AI Sistemi

## 🎯 Proje Genel Kuralları

### Kod Yazım Standartları
- **Dil:** Türkçe yorumlar ve değişken isimleri kullan
- **Format:** Prettier ve ESLint kurallarına uy
- **Indent:** 2 space kullan
- **Encoding:** UTF-8
- **Line Endings:** LF (Unix)
- **Max Line Length:** 80 karakter
- **Semicolon:** Zorunlu
- **Quotes:** Single quote kullan

### TypeScript/JavaScript Kuralları
```typescript
// Interface tanımları
interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
}

// Type tanımları
type ApiResponse<T> = {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
};

// Enum kullanımı
enum CoachType {
  GENERAL = 'general',
  RELATIONSHIP = 'relationship_coach',
  CAREER = 'career_coach',
  HEALTH = 'health_coach',
  PERSONAL_DEVELOPMENT = 'personal_development_coach',
  FINANCIAL = 'financial_coach'
}

// Async/await kullanımı
const getUserData = async (userId: string): Promise<User> => {
  try {
    const user = await User.findById(userId);
    if (!user) {
      throw new Error('Kullanıcı bulunamadı');
    }
    return user;
  } catch (error) {
    throw new Error(`Kullanıcı verisi alınamadı: ${error.message}`);
  }
};
```

### Dosya Organizasyonu
```
src/
├── controllers/          # Controller dosyaları
├── routes/              # Route dosyaları
├── models/              # Mongoose model dosyaları
├── middlewares/         # Middleware dosyaları
├── validators/          # Express-validator dosyaları
├── utils/               # Utility fonksiyonları
├── types/               # TypeScript type tanımları
├── services/            # Business logic
├── config/              # Konfigürasyon dosyaları
└── __tests__/           # Test dosyaları
```

## 🔐 Authentication & Authorization Kuralları

### JWT Token Yapısı
```typescript
// Token payload interface
interface TokenPayload {
  userId: string;
  email: string;
  role: 'user' | 'admin';
  iat: number;
  exp: number;
}

// Token oluşturma
const createToken = (user: User): string => {
  const payload: TokenPayload = {
    userId: user.id,
    email: user.email,
    role: user.role,
    iat: Date.now(),
    exp: Date.now() + (24 * 60 * 60 * 1000) // 24 saat
  };
  
  return jwt.sign(payload, process.env.JWT_SECRET!, {
    algorithm: 'HS256',
    expiresIn: '24h'
  });
};

// Token doğrulama
const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET!) as TokenPayload;
  } catch (error) {
    throw new Error('Geçersiz token');
  }
};
```

### Authentication Middleware
```typescript
// requireAuth middleware
export const requireAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        success: false,
        message: 'Authorization header eksik'
      });
      return;
    }

    const token = authHeader.split(' ')[1];
    const payload = verifyToken(token);
    
    // Kullanıcıyı veritabanından kontrol et
    const user = await User.findById(payload.userId);
    if (!user || !user.isActive) {
      res.status(401).json({
        success: false,
        message: 'Kullanıcı bulunamadı veya aktif değil'
      });
      return;
    }

    req.currentUser = user;
    next();
  } catch (error) {
    res.status(401).json({
      success: false,
      message: 'Geçersiz token'
    });
  }
};

// Role-based authorization
export const requireRole = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.currentUser) {
      res.status(401).json({
        success: false,
        message: 'Kullanıcı kimliği doğrulanamadı'
      });
      return;
    }

    if (!roles.includes(req.currentUser.role)) {
      res.status(403).json({
        success: false,
        message: 'Bu işlem için yetkiniz yok'
      });
      return;
    }

    next();
  };
};
```

### Session Management
```typescript
// Session kontrolü
export const checkSessionOwnership = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { sessionId } = req.params;
    const userId = req.currentUser?.id;

    const session = await AIChatSession.findOne({
      sessionId,
      userId,
      isActive: true
    });

    if (!session) {
      res.status(404).json({
        success: false,
        message: 'Sohbet bulunamadı veya erişim izniniz yok'
      });
      return;
    }

    req.session = session;
    next();
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Session kontrolü sırasında hata oluştu'
    });
  }
};
```

## 📡 API Response Kuralları

### Standard Response Format
```typescript
// Başarılı yanıt
interface SuccessResponse<T> {
  success: true;
  data: T;
  message?: string;
  timestamp: string;
}

// Hata yanıtı
interface ErrorResponse {
  success: false;
  message: string;
  error?: string;
  status?: number;
  timestamp: string;
}

// Response helper fonksiyonları
export const sendSuccess = <T>(
  res: Response,
  data: T,
  message?: string,
  status: number = 200
): void => {
  const response: SuccessResponse<T> = {
    success: true,
    data,
    message,
    timestamp: new Date().toISOString()
  };
  
  res.status(status).json(response);
};

export const sendError = (
  res: Response,
  message: string,
  error?: string,
  status: number = 500
): void => {
  const response: ErrorResponse = {
    success: false,
    message,
    error,
    status,
    timestamp: new Date().toISOString()
  };
  
  res.status(status).json(response);
};
```

### HTTP Status Kodları
```typescript
// Başarılı yanıtlar
200: OK                    // GET, PUT, PATCH
201: Created              // POST
204: No Content           // DELETE

// Client hataları
400: Bad Request          // Geçersiz input
401: Unauthorized         // Authentication gerekli
403: Forbidden            // Authorization yetersiz
404: Not Found            // Kaynak bulunamadı
409: Conflict             // Çakışma
422: Unprocessable Entity // Validation hatası
429: Too Many Requests    // Rate limit

// Server hataları
500: Internal Server Error
502: Bad Gateway
503: Service Unavailable
```

## 🗄️ Database Kuralları

### Mongoose Schema Kuralları
```typescript
// User Schema örneği
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'Email adresi zorunludur'],
    unique: true,
    lowercase: true,
    trim: true,
    validate: {
      validator: (email: string) => {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
      },
      message: 'Geçersiz email formatı'
    }
  },
  name: {
    type: String,
    required: [true, 'İsim zorunludur'],
    trim: true,
    minlength: [2, 'İsim en az 2 karakter olmalıdır'],
    maxlength: [50, 'İsim en fazla 50 karakter olabilir']
  },
  password: {
    type: String,
    required: [true, 'Şifre zorunludur'],
    minlength: [6, 'Şifre en az 6 karakter olmalıdır']
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastLoginAt: {
    type: Date
  }
}, {
  timestamps: true,
  toJSON: {
    transform: (doc, ret) => {
      delete ret.password;
      return ret;
    }
  }
});

// Index'ler
userSchema.index({ email: 1 });
userSchema.index({ isActive: 1 });
userSchema.index({ createdAt: -1 });

// Virtual fields
userSchema.virtual('fullName').get(function() {
  return `${this.name}`;
});

// Instance methods
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

// Static methods
userSchema.statics.findByEmail = function(email: string) {
  return this.findOne({ email, isActive: true });
};

// Pre-save middleware
userSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 12);
  }
  next();
});
```

### Query Optimizasyonu
```typescript
// Efficient query örnekleri
// ❌ Kötü
const users = await User.find().select('name email');

// ✅ İyi
const users = await User.find({ isActive: true })
  .select('name email createdAt')
  .sort({ createdAt: -1 })
  .limit(10)
  .lean();

// ❌ Kötü - N+1 problem
const sessions = await AIChatSession.find({ userId });
for (const session of sessions) {
  const user = await User.findById(session.userId);
}

// ✅ İyi - Populate kullan
const sessions = await AIChatSession.find({ userId })
  .populate('userId', 'name email')
  .lean();
```

## 🔧 Error Handling Kuralları

### Custom Error Classes
```typescript
// Base error class
class AppError extends Error {
  public statusCode: number;
  public isOperational: boolean;

  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

// Specific error classes
class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400);
  }
}

class AuthenticationError extends AppError {
  constructor(message: string = 'Kimlik doğrulama başarısız') {
    super(message, 401);
  }
}

class AuthorizationError extends AppError {
  constructor(message: string = 'Bu işlem için yetkiniz yok') {
    super(message, 403);
  }
}

class NotFoundError extends AppError {
  constructor(resource: string = 'Kaynak') {
    super(`${resource} bulunamadı`, 404);
  }
}
```

### Global Error Handler
```typescript
// Error handling middleware
export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  let statusCode = 500;
  let message = 'Sunucu hatası';

  // AppError instance kontrolü
  if (error instanceof AppError) {
    statusCode = error.statusCode;
    message = error.message;
  }

  // Mongoose validation error
  if (error.name === 'ValidationError') {
    statusCode = 400;
    message = 'Validation hatası';
  }

  // Mongoose duplicate key error
  if (error.code === 11000) {
    statusCode = 409;
    message = 'Bu kayıt zaten mevcut';
  }

  // JWT errors
  if (error.name === 'JsonWebTokenError') {
    statusCode = 401;
    message = 'Geçersiz token';
  }

  if (error.name === 'TokenExpiredError') {
    statusCode = 401;
    message = 'Token süresi dolmuş';
  }

  // Log error
  console.error('Error:', {
    message: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    userId: req.currentUser?.id
  });

  // Send response
  res.status(statusCode).json({
    success: false,
    message,
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
  });
};
```

## 📝 Validation Kuralları

### Express-Validator Kuralları
```typescript
// Validation helper
export const validateRequest = (req: Request, res: Response, next: NextFunction): void => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map(error => error.msg);
    
    res.status(400).json({
      success: false,
      message: 'Validation hatası',
      errors: errorMessages
    });
    return;
  }
  
  next();
};

// Validation rules
export const createChatSessionValidator = [
  body('title')
    .optional()
    .isString()
    .withMessage('Başlık string olmalıdır')
    .isLength({ min: 1, max: 100 })
    .withMessage('Başlık 1-100 karakter arasında olmalıdır')
    .trim(),
  
  body('coachType')
    .optional()
    .isIn(['general', 'relationship_coach', 'career_coach', 'health_coach', 'personal_development_coach', 'financial_coach'])
    .withMessage('Geçersiz koç türü'),
  
  body('coachId')
    .optional()
    .isString()
    .withMessage('Koç ID\'si string olmalıdır')
    .isLength({ min: 1 })
    .withMessage('Koç ID\'si boş olamaz'),
  
  validateRequest
];

export const sendMessageValidator = [
  body('message')
    .isString()
    .withMessage('Mesaj string olmalıdır')
    .isLength({ min: 1, max: 1000 })
    .withMessage('Mesaj 1-1000 karakter arasında olmalıdır')
    .trim(),
  
  validateRequest
];

export const updateProfileValidator = [
  body('name')
    .optional()
    .isString()
    .withMessage('İsim string olmalıdır')
    .isLength({ min: 2, max: 50 })
    .withMessage('İsim 2-50 karakter arasında olmalıdır')
    .trim(),
  
  body('email')
    .optional()
    .isEmail()
    .withMessage('Geçerli bir email adresi giriniz')
    .normalizeEmail(),
  
  validateRequest
];
```

## 🔄 Rate Limiting Kuralları

### Rate Limiting Middleware
```typescript
import rateLimit from 'express-rate-limit';

// General rate limiter
export const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 dakika
  max: 100, // IP başına maksimum 100 istek
  message: {
    success: false,
    message: 'Çok fazla istek gönderildi. Lütfen 15 dakika sonra tekrar deneyin.'
  },
  standardHeaders: true,
  legacyHeaders: false
});

// AI chat rate limiter
export const aiChatLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 dakika
  max: 10, // Kullanıcı başına maksimum 10 AI isteği
  message: {
    success: false,
    message: 'AI istek limiti aşıldı. Lütfen 1 dakika sonra tekrar deneyin.'
  },
  keyGenerator: (req) => req.currentUser?.id || req.ip
});

// Login rate limiter
export const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 dakika
  max: 5, // IP başına maksimum 5 login denemesi
  message: {
    success: false,
    message: 'Çok fazla login denemesi. Lütfen 15 dakika sonra tekrar deneyin.'
  },
  skipSuccessfulRequests: true
});
```

## 🧪 Test Kuralları

### Test Yazım Standartları
```typescript
// Test dosya yapısı
describe('AI Chat Controller', () => {
  let mockUser: User;
  let mockSession: AIChatSession;

  beforeEach(async () => {
    // Test setup
    mockUser = await createTestUser();
    mockSession = await createTestSession(mockUser.id);
  });

  afterEach(async () => {
    // Cleanup
    await cleanupTestData();
  });

  describe('POST /sessions/:sessionId/messages', () => {
    it('should send message successfully', async () => {
      // Arrange
      const message = 'Merhaba koç';
      const request = {
        body: { message },
        params: { sessionId: mockSession.sessionId },
        currentUser: mockUser
      };

      // Mock AI response
      jest.spyOn(aiClient, 'chatWithLifeCoach').mockResolvedValue({
        response: 'Merhaba! Size nasıl yardımcı olabilirim?',
        status: 'success'
      });

      // Act
      const response = await sendMessage(request as any, mockResponse);

      // Assert
      expect(response.status).toBe(200);
      expect(response.json).toHaveBeenCalledWith({
        success: true,
        data: expect.objectContaining({
          message: expect.objectContaining({
            content: 'Merhaba! Size nasıl yardımcı olabilirim?'
          })
        })
      });
    });

    it('should return 404 for non-existent session', async () => {
      // Arrange
      const request = {
        body: { message: 'Test' },
        params: { sessionId: 'non-existent' },
        currentUser: mockUser
      };

      // Act
      const response = await sendMessage(request as any, mockResponse);

      // Assert
      expect(response.status).toBe(404);
      expect(response.json).toHaveBeenCalledWith({
        success: false,
        message: 'Chat session bulunamadı'
      });
    });
  });
});
```

## 📊 Logging Kuralları

### Structured Logging
```typescript
import winston from 'winston';

// Logger configuration
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

// Development logging
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

// Logging middleware
export const requestLogger = (req: Request, res: Response, next: NextFunction): void => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    logger.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: `${duration}ms`,
      userId: req.currentUser?.id,
      userAgent: req.get('User-Agent'),
      ip: req.ip
    });
  });
  
  next();
};

// Error logging
export const errorLogger = (error: Error, req: Request): void => {
  logger.error('Application Error', {
    message: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    userId: req.currentUser?.id,
    body: req.body,
    params: req.params,
    query: req.query
  });
};
```

## 🔒 Security Kuralları

### Security Headers
```typescript
import helmet from 'helmet';

// Security middleware
export const securityMiddleware = [
  helmet(),
  helmet.contentSecurityPolicy({
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  }),
  helmet.hidePoweredBy(),
  helmet.noSniff(),
  helmet.xssFilter()
];
```

### Input Sanitization
```typescript
import DOMPurify from 'isomorphic-dompurify';

// Input sanitization
export const sanitizeInput = (input: string): string => {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [],
    ALLOWED_ATTR: []
  });
};

// Sanitization middleware
export const sanitizeBody = (req: Request, res: Response, next: NextFunction): void => {
  if (req.body) {
    Object.keys(req.body).forEach(key => {
      if (typeof req.body[key] === 'string') {
        req.body[key] = sanitizeInput(req.body[key]);
      }
    });
  }
  next();
};
```

// Bu kurallar projenin kalitesini, güvenliğini ve sürdürülebilirliğini artırmak için tasarlanmıştır. Geliştirme sürecinde bu kurallara uyulması zorunludur.
